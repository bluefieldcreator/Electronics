<input placeholder="IP Address" id="ips">
<input placeholder="Hosts" id="hosts">
<input placeholder="Nets" id="nets">
<input placeholder="Ranges" id="range">
<button onclick="calculateSubnetInfo()">
  Calculate
</button>
<div id="results">
  Results will show up here.
</div>
<ul id="range">
 
</ul>
<a href="/Electronics">Go Back</a>
<script>
function calculateSubnetInfo() {
  const usedHosts = parseInt(document.querySelector("#hosts").value);
  const usedNets = parseInt(document.querySelector("#nets").value);
  const ip = document.querySelector("#ips").value;
  const ranges = parseInt(document.querySelector("#ranges").value);


  const results = document.querySelector("#results");
  // Validate input values
  if (isNaN(usedHosts) || isNaN(usedNets)) {
    return "Invalid input. Please enter valid numbers for used hosts and used networks.";
  }

  // Extract the first octet to determine the IP class
  const firstOctet = parseInt(ip.split('.')[0], 10);

  // Determine the IP class
  let ipClass;
  if (firstOctet >= 1 && firstOctet <= 126) {
    ipClass = 'A';
  } else if (firstOctet >= 128 && firstOctet <= 191) {
    ipClass = 'B';
  } else if (firstOctet >= 192 && firstOctet <= 223) {
    ipClass = 'C';
  } else {
    return "Invalid IP address. This function only supports Class A, B, and C addresses.";
  }

  // Calculate the necessary subnet bits
  const totalSubnets = Math.pow(2, Math.ceil(Math.log2(usedNets)));
  const subnetBits = Math.ceil(Math.log2(totalSubnets));

  // Calculate the necessary host bits
  const totalHosts = Math.pow(2, Math.ceil(Math.log2(usedHosts + 2))); // '+ 2' accounts for network and broadcast addresses
  const hostBits = Math.ceil(Math.log2(totalHosts));

  // Determine the default subnet mask based on the IP class
  let defaultSubnetMask;
  if (ipClass === 'A') {
    defaultSubnetMask = '255.0.0.0';
  } else if (ipClass === 'B') {
    defaultSubnetMask = '255.255.0.0';
  } else if (ipClass === 'C') {
    defaultSubnetMask = '255.255.255.0';
  }

  // Calculate the applied subnet mask based on the number of subnet bits
  const appliedSubnetMaskBinary = '1'.repeat(subnetBits).padEnd(32, '0');
  const appliedSubnetMask = appliedSubnetMaskBinary.match(/.{1,8}/g).map(part => parseInt(part, 2)).join('.')
    const rangesArray = [];
    let currentSum = 0;
	    while (currentSum < ranges) {
        const range = [];
        for (let i = currentSum; i < currentSum + usedHosts; i++) {
        		console.log(i);
            range.push(i);
        }
        rangesArray.push(range);
        currentSum += usedHosts;
    }
    console.log(rangesArray)
	
  // Display the results
  const resultString = `
        IP Address: ${ip}
        IP Class: ${ipClass}
        Default Subnet Mask: ${defaultSubnetMask}
        Applied Subnet Mask: ${defaultSubnetMask.replace("0", appliedSubnetMask)}
        Subnet Bits: ${subnetBits}
        Host Bits: ${hostBits}
    `;
  
  results.innerHTML = resultString;
  
     function createHtmlLists(items) {
        for (let i = 0; i < items.length; i++) {
            const listContainer = document.createElement('div');
            const list = document.createElement('ul');
						let itemSumIterator = 0;
            let sum = 0;
            items[i].forEach((item) => {
            itemSumIterator += 1;
                const listItem = document.createElement('li');
                let resultedIp = "";
                let splittedIP = ip.split(".");
                if(itemSumIterator >= 256){
                	splittedIP[1] = 1;
                } else if (itemSumIterator >= 512){
                splittedIP[1] = 1
                splittedIP[2] = 2
                }
                splittedIP[3-sum] = item
                listItem.textContent = splittedIP.join(".")
                list.appendChild(listItem);
            });

            listContainer.appendChild(list);
            document.body.appendChild(listContainer);
        }
    }
    createHtmlLists(rangesArray)
  
}

// Example usage:

</script>
